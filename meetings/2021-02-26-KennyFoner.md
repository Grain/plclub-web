---
title: "Dialectic: Pragmatic, Efficient Session Types for Async Rust"
speaker: "Kenny Foner"
semester: "SP21"
---

Abstract: Session types have long promised the ability to enforce complex temporal invariants about message ordering in distributed systems, guaranteeing that a well-session-typed program always correctly follows a messaging protocol to its end. Despite their potential, these type systems have seen relatively little adoption in the mainstream. In part, this is due to their inherent reliance on linear typing, a feature not present and difficult to emulate in most popular languages. Recently, this has changed with the emergence of Rust, a systems programming language built atop a flexible "ownership type system" to track reference aliasing. Although Rust enforces in actuality a form of affine typing (weaker than the linear typing most formal session-typed calculi require) it's enough to build a library for session types that statically enforces the slightly-weaker guarantee that a program correctly follows a messaging protocol so long as it is running, but may quit the session early. Of course, this is the best we can hope to get in the real world! Networks go down, computers crash, and hardware just plain breaks. For session types to be broadly adopted, they must survive contact with this real and unpredictable world—and equally, with the real and unpredictable people who want to use them in their programs.

I've just released version 0.3 of Dialectic (https://docs.rs/dialectic): a library for pragmatic, succinct, efficient session types in Rust. Dialectic embraces Rust's burgeoning ecosystem of high-performance async networking by being polymorphic over any backend transport used to convey messages between parties. Unlike many libraries for session types, Dialectic assumes that the other party might break protocol or disconnect at any time, and is designed to gracefully handle such failures without compromising type safety.  Dialectic is designed to be used for writing specifications and programs of every size from small to large, and provides what's needed to write modular specifications and implementations of complex protocols—and not merely the regular session types expressible in most libraries, but all context-free session types.

More than merely showing off this cool thing I'm working on, I want to talk about the design process that went into making it. Designing a programming paradigm—whether you want to call it an embedded domain-specific language or merely a library—is a multi-faceted puzzle spanning considerations from psychological familiarity to formal computability. My hope is that in walking through this case study in embedded language design, we can spark more thoughts about how we as PL researchers can play in this field together and design beautiful, useful tools.

Homework:
Read through the first 2 sections "Introduction" and "Hello Tokio" of the Tokio tutorial: https://tokio.rs/tokio/tutorial. Tokio is one of the most popular async runtimes for Rust, and these pieces of its tutorial introduce the async programming model in Rust pretty well according to me. Specifically the bit about "What is asynchronous programming?" and "Compile time green threading" are relevant to the talk. Keep in mind: Rust's async/await syntax is "just do-notation for the async monad" :)

Optional extra theoretical background, check out the paper "Context Free Session Type Inference" by Luca Padovani: https://hal.archives-ouvertes.fr/hal-01385258/document. Specifically relevant is the Introduction, and Section 4: Implementation in Ocaml.

And if you want to get a jump start on playing with my library itself, check out the documentation at https://docs.rs/dialectic/0.3.0/dialectic/, tutorial at https://docs.rs/dialectic/0.3.0/dialectic/tutorial/index.html, and examples at https://github.com/boltlabs-inc/dialectic/tree/main/dialectic/examples.
