<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Proofs <span class="kn">Require Import</span> GHC.List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Src <span class="kn">Require Import</span> Queue.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Import</span> ListNotations.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">models</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a) : <span class="kt">Prop</span> :=
  front q ++ rev (back q) = xs.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk0"><span class="kn">Theorem</span> <span class="nf">models_empty</span> {<span class="nv">a</span>} : models (a := a) [] empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [] empty</div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [] empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2"><span class="kn">Theorem</span> <span class="nf">models_empty_2</span> {<span class="nv">a</span>} : models (a := a) [] empty.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [] empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [] empty</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4"><span class="nb">unfold</span> models.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front empty ++ rev (back empty) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk5"><span class="nb">cbn</span> [front empty].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] ++ rev (back empty) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk6"><span class="nb">cbn</span> [app].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev (back empty) = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk7"><span class="nb">cbn</span> [back empty].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rev [] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk8"><span class="nb">cbn</span> [rev].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">[] = []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk9"><span class="kn">Theorem</span> <span class="nf">models_push</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">x</span> : a) (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a),
    models xs q -&gt; models (xs ++ [x]) (push x q).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : a) (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a),
models xs q -&gt; models (xs ++ [x]) (push x q)</div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chka"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : a) (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a),
models xs q -&gt; models (xs ++ [x]) (push x q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkb"><span class="nb">intros</span> x xs q Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>models xs q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models (xs ++ [x]) (push x q)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkc"><span class="nb">unfold</span> models <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front q ++ rev (back q) = xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front (push x q) ++ rev (back (push x q)) = xs ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkd"><span class="nb">destruct</span> q <span class="kr">as</span> [front_q back_q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs, front_q, back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front (MkQueue front_q back_q) ++
rev (back (MkQueue front_q back_q)) = xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front (push x (MkQueue front_q back_q)) ++
rev (back (push x (MkQueue front_q back_q))) =
xs ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chke"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs, front_q, back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front_q ++ rev back_q = xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front_q ++ rev back_q ++ [x] = xs ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chkf"><span class="nb">rewrite</span> app_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs, front_q, back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front_q ++ rev back_q = xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(front_q ++ rev back_q) ++ [x] = xs ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk10"><span class="nb">rewrite</span> Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs, front_q, back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front_q ++ rev back_q = xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs ++ [x] = xs ++ [x]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk11"><span class="kn">Theorem</span> <span class="nf">models_pop</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">xs</span> : list a) (<span class="nv">y</span> : a) (<span class="nv">q</span> : Queue a),
    models (y :: xs) q -&gt;
    <span class="kr">exists</span> <span class="nv">q&#39;</span>,
      pop q = Some (y, q&#39;) /\
      models xs q&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">xs</span> : list a) (<span class="nv">y</span> : a) (<span class="nv">q</span> : Queue a),
models (y :: xs) q -&gt;
<span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\ models xs q&#39;</div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">xs</span> : list a) (<span class="nv">y</span> : a) (<span class="nv">q</span> : Queue a),
models (y :: xs) q -&gt;
<span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\ models xs q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk13"><span class="nb">intros</span> xs y q Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>models (y :: xs) q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\ models xs q&#39;</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk14"><span class="nb">unfold</span> models <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front q ++ rev (back q) = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk15"><span class="nb">destruct</span> q <span class="kr">as</span> [front_q back_q].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q, back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front (MkQueue front_q back_q) ++
rev (back (MkQueue front_q back_q)) = 
y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop (MkQueue front_q back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk16"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q, back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>front_q ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> front_q <span class="kr">with</span>
  | [] =&gt;
      <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
      | [] =&gt; None
      | y :: front =&gt; Some (y, MkQueue front [])
      <span class="kr">end</span>
  | y :: front =&gt; Some (y, MkQueue front back_q)
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk17"><span class="nb">destruct</span> front_q <span class="kr">as</span> [ | x front_q&#39; ].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>[] ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
  | [] =&gt; None
  | y :: front =&gt; Some (y, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>(x :: front_q&#39;) ++ rev back_q = y :: xs</span></span></span><br></div><label class="goal-separator" for="stdin-chk18"><hr></label><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (x, MkQueue front_q&#39; back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk19">- <span class="c">(* front is empty *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>[] ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
  | [] =&gt; None
  | y :: front =&gt; Some (y, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1a"><span class="nb">cbn</span> <span class="kr">in</span> Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
  | [] =&gt; None
  | y :: front =&gt; Some (y, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1b"><span class="nb">rewrite</span> GHC.List.hs_coq_reverse.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> rev back_q <span class="kr">with</span>
  | [] =&gt; None
  | y :: front =&gt; Some (y, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1c"><span class="nb">rewrite</span> Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (y, MkQueue xs []) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1d"><span class="kr">exists</span> (<span class="nv">MkQueue</span> <span class="nv">xs</span> []).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (y, MkQueue xs []) = Some (y, MkQueue xs []) /\
front (MkQueue xs []) ++ rev (back (MkQueue xs [])) =
xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk1e"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (y, MkQueue xs []) = Some (y, MkQueue xs [])</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><label class="goal-separator" for="stdin-chk1f"><hr></label><div class="goal-conclusion">front (MkQueue xs []) ++ rev (back (MkQueue xs [])) =
xs</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk20">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (y, MkQueue xs []) = Some (y, MkQueue xs [])</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front (MkQueue xs []) ++ rev (back (MkQueue xs [])) =
xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk22"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs ++ [] = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk23"><span class="nb">rewrite</span> app_nil_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">xs = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk24">- <span class="c">(* front is not empty *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>(x :: front_q&#39;) ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (x, MkQueue front_q&#39; back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk25"><span class="nb">cbn</span> <span class="kr">in</span> Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (x, MkQueue front_q&#39; back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk26"><span class="kr">exists</span> (<span class="nv">MkQueue</span> <span class="nv">front_q&#39;</span> <span class="nv">back_q</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q) /\
front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk27"><span class="nb">injection</span> Eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front_q&#39; ++ rev back_q = xs -&gt;
x = y -&gt;
Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q) /\
front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk28"><span class="nb">intros</span> Eq&#39; Ey.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q) /\
front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk29"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="stdin-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><label class="goal-separator" for="stdin-chk2a"><hr></label><div class="goal-conclusion">front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2c"><span class="nb">rewrite</span> Ey.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some (y, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2e"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>y, x</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>front_q', back_q</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Eq</var><span class="hyp-type"><b>: </b><span>x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>front_q&#39; ++ rev back_q = xs</span></span></span><br><span><var>Ey</var><span class="hyp-type"><b>: </b><span>x = y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">front_q&#39; ++ rev back_q = xs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Eq&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Note: &quot;Example&quot; is a synonym of &quot;Theorem&quot;. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk2f"><span class="kn">Example</span> <span class="nf">example1</span> : models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk30"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk31"><span class="nb">pose proof</span> (models_empty (a := nat)) <span class="kr">as</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models [] empty</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk32"><span class="nb">apply</span> (models_push <span class="mi">1</span>) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models ([] ++ [<span class="mi">1</span>]) (push <span class="mi">1</span> empty)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk33"><span class="nb">cbn</span> [ app ] <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models [<span class="mi">1</span>] (push <span class="mi">1</span> empty)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk34"><span class="nb">apply</span> (models_push <span class="mi">2</span>) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models ([<span class="mi">1</span>] ++ [<span class="mi">2</span>]) (push <span class="mi">2</span> (push <span class="mi">1</span> empty))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk35"><span class="nb">cbn</span> [ app ] <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models [<span class="mi">1</span>; <span class="mi">2</span>] (push <span class="mi">2</span> (push <span class="mi">1</span> empty))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk36"><span class="nb">apply</span> (models_push <span class="mi">3</span>) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models ([<span class="mi">1</span>; <span class="mi">2</span>] ++ [<span class="mi">3</span>])
  (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk37"><span class="nb">cbn</span> [ app ] <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Infix</span> <span class="s2">&quot;&lt;$&gt;&quot;</span> := option_map (<span class="kn">at level</span> <span class="mi">40</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* Infix notation for option_map : (a -&gt; b) -&gt; option a -&gt; option b *)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk38"><span class="kn">Example</span> <span class="nf">example2</span> :
  fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk39"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3a"><span class="nb">pose proof</span> example1 <span class="kr">as</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3b"><span class="nb">apply</span> models_pop <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue nat,
  pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) =
  Some (<span class="mi">1</span>, q&#39;) /\ models [<span class="mi">2</span>; <span class="mi">3</span>] q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3c"><span class="nb">destruct</span> H <span class="kr">as</span> [q&#39; [Hpop Hq&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>q'</var><span class="hyp-type"><b>: </b><span>Queue nat</span></span></span><br><span><var>Hpop</var><span class="hyp-type"><b>: </b><span>pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) =
Some (<span class="mi">1</span>, q&#39;)</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>models [<span class="mi">2</span>; <span class="mi">3</span>] q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3d"><span class="nb">rewrite</span> Hpop.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>q'</var><span class="hyp-type"><b>: </b><span>Queue nat</span></span></span><br><span><var>Hpop</var><span class="hyp-type"><b>: </b><span>pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) =
Some (<span class="mi">1</span>, q&#39;)</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>models [<span class="mi">2</span>; <span class="mi">3</span>] q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; Some (<span class="mi">1</span>, q&#39;) = Some <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3e"><span class="kn">Example</span> <span class="nf">example3</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
  models (x :: xs) q -&gt;
  fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
models (x :: xs) q -&gt;
fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
models (x :: xs) q -&gt;
fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk40"><span class="nb">intros</span> q x y xs Hq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>models (x :: xs) q</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk41"><span class="nb">pose proof</span> (models_push y (x :: xs) q Hq) <span class="kr">as</span> Hqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>models (x :: xs) q</span></span></span><br><span><var>Hqy</var><span class="hyp-type"><b>: </b><span>models ((x :: xs) ++ [y]) (push y q)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk42"><span class="nb">cbn</span> <span class="kr">in</span> Hqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span>models (x :: xs) q</span></span></span><br><span><var>Hqy</var><span class="hyp-type"><b>: </b><span>models (x :: xs ++ [y]) (push y q)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk43"><span class="nb">apply</span> models_pop <span class="kr">in</span> Hq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (x, q&#39;) /\ models xs q&#39;</span></span></span><br><span><var>Hqy</var><span class="hyp-type"><b>: </b><span>models (x :: xs ++ [y]) (push y q)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk44"><span class="nb">apply</span> models_pop <span class="kr">in</span> Hqy.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>Hq</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (x, q&#39;) /\ models xs q&#39;</span></span></span><br><span><var>Hqy</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a, pop (push y q) = Some (x, q&#39;) /\ models (xs ++ [y]) q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk45"><span class="nb">destruct</span> Hq <span class="kr">as</span> [q&#39; [Eq&#39; Hq&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>pop q = Some (x, q&#39;)</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>models xs q&#39;</span></span></span><br><span><var>Hqy</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a, pop (push y q) = Some (x, q&#39;) /\ models (xs ++ [y]) q&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk46"><span class="nb">destruct</span> Hqy <span class="kr">as</span> [qy&#39; [Eqy&#39; Hqy&#39;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>pop q = Some (x, q&#39;)</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>models xs q&#39;</span></span></span><br><span><var>qy'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eqy'</var><span class="hyp-type"><b>: </b><span>pop (push y q) = Some (x, qy&#39;)</span></span></span><br><span><var>Hqy'</var><span class="hyp-type"><b>: </b><span>models (xs ++ [y]) qy&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk47"><span class="nb">rewrite</span> Eq&#39;, Eqy&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>pop q = Some (x, q&#39;)</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>models xs q&#39;</span></span></span><br><span><var>qy'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eqy'</var><span class="hyp-type"><b>: </b><span>pop (push y q) = Some (x, qy&#39;)</span></span></span><br><span><var>Hqy'</var><span class="hyp-type"><b>: </b><span>models (xs ++ [y]) qy&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst &lt;$&gt; Some (x, qy&#39;) = fst &lt;$&gt; Some (x, q&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk48"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>q</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>a</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list a</span></span></span><br><span><var>q'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eq'</var><span class="hyp-type"><b>: </b><span>pop q = Some (x, q&#39;)</span></span></span><br><span><var>Hq'</var><span class="hyp-type"><b>: </b><span>models xs q&#39;</span></span></span><br><span><var>qy'</var><span class="hyp-type"><b>: </b><span>Queue a</span></span></span><br><span><var>Eqy'</var><span class="hyp-type"><b>: </b><span>pop (push y q) = Some (x, qy&#39;)</span></span></span><br><span><var>Hqy'</var><span class="hyp-type"><b>: </b><span>models (xs ++ [y]) qy&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Some x = Some x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk49"><span class="kn">Theorem</span> <span class="nf">injective_models</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">xs</span> <span class="nv">ys</span> : list a),
  models xs q -&gt;
  models ys q -&gt;
  xs = ys.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">xs</span> <span class="nv">ys</span> : list a),
models xs q -&gt; models ys q -&gt; xs = ys</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">xs</span> <span class="nv">ys</span> : list a),
models xs q -&gt; models ys q -&gt; xs = ys</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Exercise for the reader (easy) *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* Apply a function on the second component of a pair. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">map_snd</span> {<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span>} (<span class="nv">f</span> : b -&gt; b&#39;) (<span class="nv">xy</span> : a * b) : a * b&#39; :=
  (fst xy, f (snd xy)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* False! *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="stdin-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="stdin-chk4b"><span class="kn">Theorem</span> <span class="nf">invalid_push_pop_comm</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
  models (x :: xs) q -&gt;
  pop (push y q) = map_snd (push y) &lt;$&gt; pop q.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
models (x :: xs) q -&gt;
pop (push y q) = map_snd (push y) &lt;$&gt; pop q</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span></span></pre><!-- alectryon-block-end -->
