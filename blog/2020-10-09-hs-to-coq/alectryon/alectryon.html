<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Proofs <span class="kn">Require Import</span> GHC.List.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Src <span class="kn">Require Import</span> Queue.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Import</span> ListNotations.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">models</span> {<span class="nv">a</span>} (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a) : <span class="kt">Prop</span> :=
  front q ++ rev (back q) = xs.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk0" style="display: none" type="checkbox"><label class="coq-input" for="--chk0"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">models_empty</span> {<span class="nv">a</span>} : models (a := a) [] empty.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [] empty</span></div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk1" style="display: none" type="checkbox"><label class="coq-input" for="--chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [] empty</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk2" style="display: none" type="checkbox"><label class="coq-input" for="--chk2"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">models_empty_2</span> {<span class="nv">a</span>} : models (a := a) [] empty.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [] empty</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk3" style="display: none" type="checkbox"><label class="coq-input" for="--chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [] empty</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk4" style="display: none" type="checkbox"><label class="coq-input" for="--chk4"><span class="highlight"><span class="nb">unfold</span> models.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front empty ++ rev (back empty) = []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk5" style="display: none" type="checkbox"><label class="coq-input" for="--chk5"><span class="highlight"><span class="nb">cbn</span> [front empty].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[] ++ rev (back empty) = []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk6" style="display: none" type="checkbox"><label class="coq-input" for="--chk6"><span class="highlight"><span class="nb">cbn</span> [app].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">rev (back empty) = []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk7" style="display: none" type="checkbox"><label class="coq-input" for="--chk7"><span class="highlight"><span class="nb">cbn</span> [back empty].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">rev [] = []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk8" style="display: none" type="checkbox"><label class="coq-input" for="--chk8"><span class="highlight"><span class="nb">cbn</span> [rev].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[] = []</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk9" style="display: none" type="checkbox"><label class="coq-input" for="--chk9"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">models_push</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">x</span> : a) (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a),
    models xs q -&gt; models (xs ++ [x]) (push x q).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : a) (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a),
models xs q -&gt; models (xs ++ [x]) (push x q)</span></div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chka" style="display: none" type="checkbox"><label class="coq-input" for="--chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : a) (<span class="nv">xs</span> : list a) (<span class="nv">q</span> : Queue a),
models xs q -&gt; models (xs ++ [x]) (push x q)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chkb" style="display: none" type="checkbox"><label class="coq-input" for="--chkb"><span class="highlight"><span class="nb">intros</span> x xs q Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models xs q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models (xs ++ [x]) (push x q)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chkc" style="display: none" type="checkbox"><label class="coq-input" for="--chkc"><span class="highlight"><span class="nb">unfold</span> models <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front q ++ rev (back q) = xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front (push x q) ++ rev (back (push x q)) = xs ++ [x]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chkd" style="display: none" type="checkbox"><label class="coq-input" for="--chkd"><span class="highlight"><span class="nb">destruct</span> q <span class="kr">as</span> [front_q back_q].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs, front_q, back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front (MkQueue front_q back_q) ++
rev (back (MkQueue front_q back_q)) = xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front (push x (MkQueue front_q back_q)) ++
rev (back (push x (MkQueue front_q back_q))) =
xs ++ [x]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chke" style="display: none" type="checkbox"><label class="coq-input" for="--chke"><span class="highlight"><span class="nb">cbn</span> <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs, front_q, back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q ++ rev back_q = xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front_q ++ rev back_q ++ [x] = xs ++ [x]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chkf" style="display: none" type="checkbox"><label class="coq-input" for="--chkf"><span class="highlight"><span class="nb">rewrite</span> app_assoc.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs, front_q, back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q ++ rev back_q = xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(front_q ++ rev back_q) ++ [x] = xs ++ [x]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk10" style="display: none" type="checkbox"><label class="coq-input" for="--chk10"><span class="highlight"><span class="nb">rewrite</span> Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs, front_q, back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q ++ rev back_q = xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">xs ++ [x] = xs ++ [x]</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk11" style="display: none" type="checkbox"><label class="coq-input" for="--chk11"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">models_pop</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">xs</span> : list a) (<span class="nv">y</span> : a) (<span class="nv">q</span> : Queue a),
    models (y :: xs) q -&gt;
    <span class="kr">exists</span> <span class="nv">q&#39;</span>,
      pop q = Some (y, q&#39;) /\
      models xs q&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">xs</span> : list a) (<span class="nv">y</span> : a) (<span class="nv">q</span> : Queue a),
models (y :: xs) q -&gt;
<span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\ models xs q&#39;</span></div></blockquote></div></div></small></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk12" style="display: none" type="checkbox"><label class="coq-input" for="--chk12"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">xs</span> : list a) (<span class="nv">y</span> : a) (<span class="nv">q</span> : Queue a),
models (y :: xs) q -&gt;
<span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\ models xs q&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk13" style="display: none" type="checkbox"><label class="coq-input" for="--chk13"><span class="highlight"><span class="nb">intros</span> xs y q Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (y :: xs) q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\ models xs q&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk14" style="display: none" type="checkbox"><label class="coq-input" for="--chk14"><span class="highlight"><span class="nb">unfold</span> models <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front q ++ rev (back q) = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk15" style="display: none" type="checkbox"><label class="coq-input" for="--chk15"><span class="highlight"><span class="nb">destruct</span> q <span class="kr">as</span> [front_q back_q].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q, back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front (MkQueue front_q back_q) ++
rev (back (MkQueue front_q back_q)) = 
y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop (MkQueue front_q back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk16" style="display: none" type="checkbox"><label class="coq-input" for="--chk16"><span class="highlight"><span class="nb">cbn</span> <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q, back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> front_q <span class="kr">with</span>
  | [] =&gt;
      <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
      | [] =&gt; None
      | y0 :: front =&gt; Some (y0, MkQueue front [])
      <span class="kr">end</span>
  | y0 :: front =&gt; Some (y0, MkQueue front back_q)
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk17" style="display: none" type="checkbox"><label class="coq-input" for="--chk17"><span class="highlight"><span class="nb">destruct</span> front_q <span class="kr">as</span> [ | x front_q&#39; ].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[] ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
  | [] =&gt; None
  | y0 :: front =&gt; Some (y0, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="--chk18" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(x :: front_q&#39;) ++ rev back_q = y :: xs</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="--chk18"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (x, MkQueue front_q&#39; back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk19" style="display: none" type="checkbox"><label class="coq-input" for="--chk19"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">[] ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
  | [] =&gt; None
  | y0 :: front =&gt; Some (y0, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* front is empty *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk1a" style="display: none" type="checkbox"><label class="coq-input" for="--chk1a"><span class="highlight"><span class="nb">cbn</span> <span class="kr">in</span> Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> GHC.List.reverse back_q <span class="kr">with</span>
  | [] =&gt; None
  | y0 :: front =&gt; Some (y0, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk1b" style="display: none" type="checkbox"><label class="coq-input" for="--chk1b"><span class="highlight"><span class="nb">rewrite</span> GHC.List.hs_coq_reverse.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  <span class="kr">match</span> rev back_q <span class="kr">with</span>
  | [] =&gt; None
  | y0 :: front =&gt; Some (y0, MkQueue front [])
  <span class="kr">end</span> = Some (y, q&#39;) /\ 
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk1c" style="display: none" type="checkbox"><label class="coq-input" for="--chk1c"><span class="highlight"><span class="nb">rewrite</span> Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (y, MkQueue xs []) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk1d" style="display: none" type="checkbox"><label class="coq-input" for="--chk1d"><span class="highlight"><span class="kr">exists</span> (<span class="nv">MkQueue</span> <span class="nv">xs</span> []).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (y, MkQueue xs []) = Some (y, MkQueue xs []) /\
front (MkQueue xs []) ++ rev (back (MkQueue xs [])) =
xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk1e" style="display: none" type="checkbox"><label class="coq-input" for="--chk1e"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (y, MkQueue xs []) = Some (y, MkQueue xs [])</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="--chk1f" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="--chk1f"><hr></label><div class="goal-conclusion"><span class="highlight">front (MkQueue xs []) ++ rev (back (MkQueue xs [])) =
xs</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk20" style="display: none" type="checkbox"><label class="coq-input" for="--chk20"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (y, MkQueue xs []) = Some (y, MkQueue xs [])</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk21" style="display: none" type="checkbox"><label class="coq-input" for="--chk21"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front (MkQueue xs []) ++ rev (back (MkQueue xs [])) =
xs</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk22" style="display: none" type="checkbox"><label class="coq-input" for="--chk22"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">xs ++ [] = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="--chk23" style="display: none" type="checkbox"><label class="coq-input" for="--chk23"><span class="highlight"><span class="nb">rewrite</span> app_nil_r.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">xs = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk24" style="display: none" type="checkbox"><label class="coq-input" for="--chk24"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">(x :: front_q&#39;) ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (x, MkQueue front_q&#39; back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small></span><span class="coq-wsp"><span class="highlight"> <span class="c">(* front is not empty *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk25" style="display: none" type="checkbox"><label class="coq-input" for="--chk25"><span class="highlight"><span class="nb">cbn</span> <span class="kr">in</span> Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  Some (x, MkQueue front_q&#39; back_q) = Some (y, q&#39;) /\
  front q&#39; ++ rev (back q&#39;) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk26" style="display: none" type="checkbox"><label class="coq-input" for="--chk26"><span class="highlight"><span class="kr">exists</span> (<span class="nv">MkQueue</span> <span class="nv">front_q&#39;</span> <span class="nv">back_q</span>).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q) /\
front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk27" style="display: none" type="checkbox"><label class="coq-input" for="--chk27"><span class="highlight"><span class="nb">injection</span> Eq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front_q&#39; ++ rev back_q = xs -&gt;
x = y -&gt;
Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q) /\
front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk28" style="display: none" type="checkbox"><label class="coq-input" for="--chk28"><span class="highlight"><span class="nb">intros</span> Eq&#39; Ey.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q) /\
front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk29" style="display: none" type="checkbox"><label class="coq-input" for="--chk29"><span class="highlight"><span class="nb">split</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="--chk2a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="--chk2a"><hr></label><div class="goal-conclusion"><span class="highlight">front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk2b" style="display: none" type="checkbox"><label class="coq-input" for="--chk2b"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (x, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk2c" style="display: none" type="checkbox"><label class="coq-input" for="--chk2c"><span class="highlight"><span class="nb">rewrite</span> Ey.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some (y, MkQueue front_q&#39; back_q) =
Some (y, MkQueue front_q&#39; back_q)</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="--chk2d" style="display: none" type="checkbox"><label class="coq-input" for="--chk2d"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front (MkQueue front_q&#39; back_q) ++
rev (back (MkQueue front_q&#39; back_q)) = xs</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk2e" style="display: none" type="checkbox"><label class="coq-input" for="--chk2e"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">front_q', back_q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x :: front_q&#39; ++ rev back_q = y :: xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">front_q&#39; ++ rev back_q = xs</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ey</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">x = y</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">front_q&#39; ++ rev back_q = xs</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Eq&#39;.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Note: &quot;Example&quot; is a synonym of &quot;Theorem&quot;. *)</span>
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk2f" style="display: none" type="checkbox"><label class="coq-input" for="--chk2f"><span class="highlight"><span class="kn">Example</span> <span class="nf">example1</span> : models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk30" style="display: none" type="checkbox"><label class="coq-input" for="--chk30"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk31" style="display: none" type="checkbox"><label class="coq-input" for="--chk31"><span class="highlight"><span class="nb">pose proof</span> (models_empty (a := nat)) <span class="kr">as</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [] empty</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk32" style="display: none" type="checkbox"><label class="coq-input" for="--chk32"><span class="highlight"><span class="nb">apply</span> (models_push <span class="mi">1</span>) <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models ([] ++ [<span class="mi">1</span>]) (push <span class="mi">1</span> empty)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk33" style="display: none" type="checkbox"><label class="coq-input" for="--chk33"><span class="highlight"><span class="nb">cbn</span> [ app ] <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [<span class="mi">1</span>] (push <span class="mi">1</span> empty)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk34" style="display: none" type="checkbox"><label class="coq-input" for="--chk34"><span class="highlight"><span class="nb">apply</span> (models_push <span class="mi">2</span>) <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models ([<span class="mi">1</span>] ++ [<span class="mi">2</span>]) (push <span class="mi">2</span> (push <span class="mi">1</span> empty))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk35" style="display: none" type="checkbox"><label class="coq-input" for="--chk35"><span class="highlight"><span class="nb">cbn</span> [ app ] <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>] (push <span class="mi">2</span> (push <span class="mi">1</span> empty))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk36" style="display: none" type="checkbox"><label class="coq-input" for="--chk36"><span class="highlight"><span class="nb">apply</span> (models_push <span class="mi">3</span>) <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models ([<span class="mi">1</span>; <span class="mi">2</span>] ++ [<span class="mi">3</span>])
  (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk37" style="display: none" type="checkbox"><label class="coq-input" for="--chk37"><span class="highlight"><span class="nb">cbn</span> [ app ] <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;$&gt;&quot;</span> := option_map (<span class="kn">at level</span> <span class="mi">40</span>).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* Infix notation for option_map : (a -&gt; b) -&gt; option a -&gt; option b *)</span>

</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk38" style="display: none" type="checkbox"><label class="coq-input" for="--chk38"><span class="highlight"><span class="kn">Example</span> <span class="nf">example2</span> :
  fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk39" style="display: none" type="checkbox"><label class="coq-input" for="--chk39"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk3a" style="display: none" type="checkbox"><label class="coq-input" for="--chk3a"><span class="highlight"><span class="nb">pose proof</span> example1 <span class="kr">as</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [<span class="mi">1</span>; <span class="mi">2</span>; <span class="mi">3</span>] (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty)))</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk3b" style="display: none" type="checkbox"><label class="coq-input" for="--chk3b"><span class="highlight"><span class="nb">apply</span> models_pop <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue nat,
  pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) =
  Some (<span class="mi">1</span>, q&#39;) /\ models [<span class="mi">2</span>; <span class="mi">3</span>] q&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk3c" style="display: none" type="checkbox"><label class="coq-input" for="--chk3c"><span class="highlight"><span class="nb">destruct</span> H <span class="kr">as</span> [q&#39; [Hpop Hq&#39;]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">q'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hpop</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) =
Some (<span class="mi">1</span>, q&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [<span class="mi">2</span>; <span class="mi">3</span>] q&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk3d" style="display: none" type="checkbox"><label class="coq-input" for="--chk3d"><span class="highlight"><span class="nb">rewrite</span> Hpop.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">q'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue nat</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hpop</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop (push <span class="mi">3</span> (push <span class="mi">2</span> (push <span class="mi">1</span> empty))) =
Some (<span class="mi">1</span>, q&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models [<span class="mi">2</span>; <span class="mi">3</span>] q&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; Some (<span class="mi">1</span>, q&#39;) = Some <span class="mi">1</span></span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk3e" style="display: none" type="checkbox"><label class="coq-input" for="--chk3e"><span class="highlight"><span class="kn">Example</span> <span class="nf">example3</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
  models (x :: xs) q -&gt;
  fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
models (x :: xs) q -&gt;
fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk3f" style="display: none" type="checkbox"><label class="coq-input" for="--chk3f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
models (x :: xs) q -&gt;
fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk40" style="display: none" type="checkbox"><label class="coq-input" for="--chk40"><span class="highlight"><span class="nb">intros</span> q x y xs Hq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (x :: xs) q</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk41" style="display: none" type="checkbox"><label class="coq-input" for="--chk41"><span class="highlight"><span class="nb">pose proof</span> (models_push y (x :: xs) q Hq) <span class="kr">as</span> Hqy.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (x :: xs) q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models ((x :: xs) ++ [y]) (push y q)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk42" style="display: none" type="checkbox"><label class="coq-input" for="--chk42"><span class="highlight"><span class="nb">cbn</span> <span class="kr">in</span> Hqy.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (x :: xs) q</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (x :: xs ++ [y]) (push y q)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk43" style="display: none" type="checkbox"><label class="coq-input" for="--chk43"><span class="highlight"><span class="nb">apply</span> models_pop <span class="kr">in</span> Hq.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (x, q&#39;) /\ models xs q&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (x :: xs ++ [y]) (push y q)</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk44" style="display: none" type="checkbox"><label class="coq-input" for="--chk44"><span class="highlight"><span class="nb">apply</span> models_pop <span class="kr">in</span> Hqy.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a,
  pop q = Some (x, q&#39;) /\ models xs q&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;</span> : Queue a, pop (push y q) = Some (x, q&#39;) /\ models (xs ++ [y]) q&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk45" style="display: none" type="checkbox"><label class="coq-input" for="--chk45"><span class="highlight"><span class="nb">destruct</span> Hq <span class="kr">as</span> [q&#39; [Eq&#39; Hq&#39;]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop q = Some (x, q&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models xs q&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kr">exists</span> <span class="nv">q&#39;0</span> : Queue a,
pop (push y q) = Some (x, q&#39;0) /\ models (xs ++ [y]) q&#39;0</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk46" style="display: none" type="checkbox"><label class="coq-input" for="--chk46"><span class="highlight"><span class="nb">destruct</span> Hqy <span class="kr">as</span> [qy&#39; [Eqy&#39; Hqy&#39;]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop q = Some (x, q&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models xs q&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">qy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eqy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop (push y q) = Some (x, qy&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (xs ++ [y]) qy&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; pop (push y q) = fst &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk47" style="display: none" type="checkbox"><label class="coq-input" for="--chk47"><span class="highlight"><span class="nb">rewrite</span> Eq&#39;, Eqy&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop q = Some (x, q&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models xs q&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">qy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eqy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop (push y q) = Some (x, qy&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (xs ++ [y]) qy&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fst &lt;$&gt; Some (x, qy&#39;) = fst &lt;$&gt; Some (x, q&#39;)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="--chk48" style="display: none" type="checkbox"><label class="coq-input" for="--chk48"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">xs</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">list a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">q'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop q = Some (x, q&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hq'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models xs q&#39;</span></span></span></div><div class="goal-hyp"><span class="hyp-names">qy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">Queue a</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Eqy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">pop (push y q) = Some (x, qy&#39;)</span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hqy'</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight">models (xs ++ [y]) qy&#39;</span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Some x = Some x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-sentence"><input class="coq-toggle" id="--chk49" style="display: none" type="checkbox"><label class="coq-input" for="--chk49"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">injective_models</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">xs</span> <span class="nv">ys</span> : list a),
  models xs q -&gt;
  models ys q -&gt;
  xs = ys.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">xs</span> <span class="nv">ys</span> : list a),
models xs q -&gt; models ys q -&gt; xs = ys</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk4a" style="display: none" type="checkbox"><label class="coq-input" for="--chk4a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">xs</span> <span class="nv">ys</span> : list a),
models xs q -&gt; models ys q -&gt; xs = ys</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(* Exercise for the reader (easy) *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><!-- alectryon-block-end -->
<pre class="alectryon-io"><!-- Generator: Alectryon v0.2 --><span class="coq-wsp"><span class="highlight"><span class="c">(* Apply a function on the second component of a pair. *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_snd</span> {<span class="nv">a</span> <span class="nv">b</span> <span class="nv">b&#39;</span>} (<span class="nv">f</span> : b -&gt; b&#39;) (<span class="nv">xy</span> : a * b) : a * b&#39; :=
  (fst xy, f (snd xy)).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="c">(* False! *)</span>
</span></span><span class="coq-sentence"><input class="coq-toggle" id="--chk4b" style="display: none" type="checkbox"><label class="coq-input" for="--chk4b"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">invalid_push_pop_comm</span> {<span class="nv">a</span>} : <span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
  models (x :: xs) q -&gt;
  pop (push y q) = map_snd (push y) &lt;$&gt; pop q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type"><span class="hyp-punct">:</span><span class="highlight"><span class="kt">Type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">q</span> : Queue a) (<span class="nv">x</span> <span class="nv">y</span> : a) (<span class="nv">xs</span> : list a),
models (x :: xs) q -&gt;
pop (push y q) = map_snd (push y) &lt;$&gt; pop q</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre><!-- alectryon-block-end -->
